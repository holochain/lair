use sodoken::{SodokenError, SodokenResult};

use std::future::Future;
use std::sync::Arc;

/// The hcSeedBundle spec specifies a fixed KDF context of b"SeedBndl".
const KDF_CONTEXT: &[u8; 8] = b"SeedBndl";

/// This is the main struct for interacting with SeedBundles.
#[derive(Clone)]
pub struct UnlockedSeedBundle {
    seed: sodoken::BufReadSized<32>,
    sign_pub_key: sodoken::BufReadSized<{ sodoken::sign::SIGN_PUBLICKEYBYTES }>,
    sign_sec_key: sodoken::BufReadSized<{ sodoken::sign::SIGN_SECRETKEYBYTES }>,
    app_data: Arc<[u8]>,
}

impl UnlockedSeedBundle {
    /// Private core constructor
    pub(crate) async fn priv_from_seed(
        seed: sodoken::BufReadSized<32>,
    ) -> SodokenResult<Self> {
        // generate the deterministic signature keypair represented by this seed
        let pk = sodoken::BufWriteSized::new_no_lock();
        let sk = sodoken::BufWriteSized::new_mem_locked()?;
        sodoken::sign::sign_seed_keypair(pk.clone(), sk.clone(), seed.clone())
            .await?;

        // generate the full struct bundle with blank app_data
        Ok(Self {
            seed,
            sign_pub_key: pk.to_read_sized(),
            sign_sec_key: sk.to_read_sized(),
            app_data: Arc::new([]),
        })
    }

    /// Construct a new random seed SeedBundle.
    pub async fn new_random() -> SodokenResult<Self> {
        let seed = sodoken::BufWriteSized::new_mem_locked()?;
        sodoken::random::randombytes_buf(seed.clone()).await?;
        Self::priv_from_seed(seed.to_read_sized()).await
    }

    /// Decode locked SeedBundle bytes into a list of
    /// LockedSeedCiphers to be used for decrypting the bundle.
    pub async fn from_locked(
        bytes: &[u8],
    ) -> SodokenResult<Vec<crate::LockedSeedCipher>> {
        crate::LockedSeedCipher::from_locked(bytes)
    }

    /// Derive a new sub SeedBundle by given index.
    pub fn derive(
        &self,
        index: u32,
    ) -> impl Future<Output = SodokenResult<Self>> + 'static + Send {
        let seed = self.seed.clone();
        async move {
            let new_seed = sodoken::BufWriteSized::new_mem_locked()?;
            sodoken::kdf::derive_from_key(
                new_seed.clone(),
                index as u64,
                *KDF_CONTEXT,
                seed,
            )?;
            Self::priv_from_seed(new_seed.to_read_sized()).await
        }
    }

    /// Get the signature pub key generated by this seed.
    pub fn get_sign_pub_key(
        &self,
    ) -> sodoken::BufReadSized<{ sodoken::sign::SIGN_PUBLICKEYBYTES }> {
        self.sign_pub_key.clone()
    }

    /// Sign some data with the secret key generated by this seed.
    pub fn sign_detached<M>(
        &self,
        message: M,
    ) -> impl Future<
        Output = SodokenResult<
            sodoken::BufReadSized<{ sodoken::sign::SIGN_BYTES }>,
        >,
    >
           + 'static
           + Send
    where
        M: Into<sodoken::BufRead> + 'static + Send,
    {
        let sign_sec_key = self.sign_sec_key.clone();
        async move {
            let sig = sodoken::BufWriteSized::new_no_lock();
            sodoken::sign::sign_detached(sig.clone(), message, sign_sec_key)
                .await?;
            Ok(sig.to_read_sized())
        }
    }

    /// Get the raw appData bytes.
    pub fn get_app_data_bytes(&self) -> &[u8] {
        &self.app_data
    }

    /// Set the raw appData bytes.
    pub fn set_app_data_bytes<B>(&mut self, app_data: B)
    where
        B: Into<Arc<[u8]>>,
    {
        self.app_data = app_data.into();
    }

    /// Get the decoded appData bytes by type.
    pub fn get_app_data<T>(&self) -> SodokenResult<T>
    where
        T: 'static + for<'de> serde::Deserialize<'de>,
    {
        rmp_serde::from_read_ref(&self.app_data).map_err(SodokenError::other)
    }

    /// Set the encoded appData bytes by type.
    pub fn set_app_data<T>(&mut self, t: &T) -> SodokenResult<()>
    where
        T: serde::Serialize,
    {
        let mut se = rmp_serde::encode::Serializer::new(Vec::new())
            .with_struct_map()
            .with_string_variants();
        t.serialize(&mut se).map_err(SodokenError::other)?;
        self.app_data = se.into_inner().into_boxed_slice().into();
        Ok(())
    }

    /// Get a SeedCipherBuilder that will allow us to lock this bundle.
    pub fn lock(&self) -> crate::SeedCipherBuilder {
        crate::SeedCipherBuilder::new(self.seed.clone(), self.app_data.clone())
    }
}
